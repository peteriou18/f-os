 .( Block 1 )                                                    : LATEST    CURRENT @ @ ;  : IMMEDIATE  LATEST    80 OR! ;      : BIN: CREATE code_top  @  to_cf ;  IMMEDIATE                   : ;BIN 0 , ;    IMMEDIATE                                       0x C3 1 opcode ret             0x E8 1 opcode call              0x 20A label pop_code          0x 1FA label push_code           0 0x ff 0x 66 0x 67  0x 4  opcode inc_[eax]                     0x 3 0x 89 0x 67 0x 2e 0x 4 opcode   mov_[cs:ebx],ax            0x 02 0x 00 0x 83 0x 66 0x 67 0x 5 opcode  add_[eax],2          0x 04  0x 00  0x 83 0x 66 0x 67 0x 5 opcode  add_[eax],4        BIN: 1+!  call pop_code  inc_[eax] ret                          0x 3 0x 88 0x 67 0x 2e 0x 4 opcode mov_[cs:ebx],al              0x 3  0x 89 0x 67 0x 66 0x 2e 0x 5 opcode    mov_[cs:ebx],eax   BIN: 2+! call pop_code add_[eax],2  ret                         BIN: 4+! call pop_code  add_[eax],4  ret                        0x C3 0x 89 0x 66 0x 3 opcode mov_ebx,eax                       code_top @   label  pop_ab   call  pop_code  mov_ebx,eax        call  pop_code  ret                                             variable_code label var_        addr_interpreter label addr_i   0x e2 0x 88  0x 2 opcode  mov_dl,ah                             0x c2 0x 89 0x 66 0x 3 opcode mov_edx,eax                       0x c2 0x 81 0x 66 0x 3 opcode add_edx,                                0x 05 0x 66 0x 2 opcode add_eax,                          0x d8 0x 01 0x 66 0x 3 opcode add_eax,ebx                       0x d8 0x 29 0x 66 0x 3 opcode sub_eax,ebx                       0x d8 0x 21 0x 66 0x 3 opcode and_eax,ebx                       0x d8 0x 09 0x 66 0x 3 opcode  or_eax,ebx                       0x d8 0x 31 0x 66 0x 3 opcode xor_eax,ebx                       0x eb 0x f7 0x 66 0x 3 opcode imul_ebx                          0x 90 1 opcode nop        0x B8  0x 01 opcode mov_ax,           BIN: bCode,     call pop_ab     mov_[cs:ebx],al ret             BIN: wCode,     call pop_ab     mov_[cs:ebx],ax ret             BIN: dCode,     call pop_ab     mov_[cs:ebx],eax ret            : b# 0x code_top @ bCode, code_top 1+! ;                        : w# 0x code_top @ wCode, code_top 2+! ;                        : d# 0x code_top @ dCode, code_top 4+! ;                        0x ba 0x 66 0x 2 opcode mov_edx,                                0x 2 0x 88 0x 67 0x 3 opcode   mov_[edx],al                     BIN:  +    call pop_ab  add_eax,ebx  call push_code  ret        BIN:  -    call pop_ab  sub_eax,ebx  call push_code  ret        BIN:  *    call pop_ab  imul_ebx     call push_code  ret        BIN: AND   call pop_ab  and_eax,ebx  call push_code  ret        BIN: XOR   call pop_ab  xor_eax,ebx  call push_code  ret        BIN: OR    call pop_ab  or_eax,ebx   call push_code  ret        0x c0 0x 9d 0x 0f 0x 3 opcode   setge_al                        0x ba 1 opcode mov_dx, 0x d 0x 66 0x 2 opcode or_eax,           0x 2 LOAD  0x 3 LOAD  0x 4 LOAD  0x 5 LOAD  0x 6 LOAD           0x 7 LOAD  0x 8 LOAD  CR  .( All blocks loaded ) CR             .( Welcome! )   .. ...............................................................................................................................................................................................................................................bbbbbbbbc.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................... .( Block 2. )                                                   0x 0E 0x 0D 0x B8 0x 03  opcode    mov_ax,0e0dh                 0x 0E 0x 0A 0x B8 0x  3  opcode    mov_ax,0e0ah                 0x 10 0x CD 0x 2         opcode    int_10h                      0x 0E 0x B4 0x 2         opcode    mov_ah,0eh                   0x 11 0x D5 0x 37 0x 3   opcode    aaa_17                       0x 30 0x B4 0x 2         opcode    mov_ah,30h                   0x 0F 0x 24 0x 2         opcode    and_al,0fh                   0x D8 0x 88 0x 2         opcode    mov_al,bl                    0x 04 0x C3 0x C1 0x 66 0x 4   opcode   rol_ebx,4               0x 43 1  opcode  inc_bx   0x C0 0x 31 0x 2 opcode xor_ax,ax     0x 16 0x CD 0x 2 opcode int_16h                                 0x 0 0x B6 0x 0F 0x 66 0x 67 0x 5 opcode movzx_eax,b[eax]       0x 40 0x 66 0x 2 opcode  inc_eax                                0x 08 0x FF 0x 66 0x 67 0x 04  opcode dec_d[eax]                0x 01 0x b7 0x 2         opcode     mov_bh,1                    0x 03 0x b5 0x 2         opcode     mov_ch,3                    0x  3 0x b1 0x 2         opcode     mov_cl,3                    0x 13 0x b6 0x 2         opcode     mov_dh,13h                  0x 43 0x 43 0x 2 opcode mov_dl,43h                              1 0x b0 0x 2 opcode mov_al,1  0x 6 0x B4 0x 2 opcode mov_ah,6   0x  7 0x B4 0x 2         opcode     mov_ah,7                    0x  7 0x c7 0x 64 0x 3   opcode     mov_[fs:bx],                0x e2 1 opcode loop      0x c3 0x 89 0x 2 opcode mov_bx,ax      0x b9 1 opcode mov_cx, 0x e0 0x d1 0x 66 0x 3 opcode shl_eax,1  0x c3 0x 81 0x 2 opcode add_bx,                                 0x 3 0x c7 0x 67 0x 64 0x 4    opcode          mov_w[fs:ebx],   0x 48 0x 66 0x 2 opcode  dec_eax   0x 85 0x f 0x 2 opcode  jne  0x 43 0x 66 0x 2 opcode  inc_ebx                                0x c3 0x 81 0x 66 0x 3  opcode  add_ebx,                        0x 0 0x c7 0x 67 0x 64  0x 4    opcode   mov_w[fs:eax],         0x e0 0x c1 0x 66 0x 3 opcode   shl_eax,                        0x 50  0x 66    0x 2  opcode    push_eax                        0x db 0x 31 0x 66 0x 3  opcode  xor_ebx,ebx                     0x 02 0x 8a 0x 67 0x 3  opcode  mov_al,[edx]                    0x 59 0x 66 0x 2 opcode pop_ecx 0x 49 0x 66 0x 2 opcode dec_ecx 0x 42 0x 66 0x 2 opcode inc_edx                                 0x d9 0x 89 0x 2 opcode   mov_ecx,ebx                           0x B4 1 opcode mov_ah,         0x 4f 1 opcode dec_di            0x 3 0x 89 0x 67 0x 64 0x 4  opcode   mov_[fs:ebx],ax           0x 51 0x 66 0x 2 opcode push_ecx                                0x c1 0x 89 0x 66  0x 3  opcode mov_ecx,eax                     0x d2 0x 31 0x  66 0x 3  opcode xor_edx,edx                     0x 03 0x 8a 0x  67 0x 3  opcode  mov_al,[ebx]                   0x 2 0x 89 0x 67 0x 64  0x 4  opcode  mov_[fs:edx],ax           0x b8 0x 66 0x 2 opcode  mov_eax,     0x e9 1  opcode  jmp      0x c0 0x 9c 0x 0f 0x 3 opcode   setl_al                         0x c0 0x 9e 0x 0f 0x 3 opcode   setle_al                        0x c3 0x 39 0x 66 0x 3 opcode   cmp_ebx,eax                     0x c0 0x be 0x 0f 0x 66 0x 4   opcode movsx_eax,al              0x 3 0x 01 0x 66 0x 67 0x 4 opcode  add_[ebx],eax               0x 18 0x 01 0x 66 0x 67 0x 4 opcode  add_[eax],ebx              0x 3 0x 01 0x 66 0x 67 0x 64 0x 5  opcode  add_fs:[ebx],eax     0x e8 0x d1 0x 66 0x 3 opcode  shr_eax,1                        0x f3 0x f7 0x 66 0x 3  opcode  div_ebx                         0x c4 0x 88 0x 2 opcode mov_ah,al                               0x d0 0x 89 0x 66   0x 3 opcode  mov_eax,edx                    0x c6 0x 88         0x 2 opcode mov_dh,al                                          ..        ..                                                                                                                                                                                                                                                                                                                                                                 .( Block 3 )                                                    : NAME>    N>LINK +CELL ;     LATEST NAME> CONSTANT  does-d     : part-one     call  var_    mov_eax, ;                         : part-two     jmp  addr_i  ;                                   : DOES>        code_top @ lit_code , , does-d ,                     HERE @ part-one        code_top @ dCode,      code_top 4+!      part-two   ret_ ,  ; IMMEDIATE                                0x d8 0x 89 0x 66 0x 3  opcode     mov_eax,ebx                  0x c8 0x 89 0x 66 0x 3  opcode     mov_eax,ecx                0x 40 0x 04 0x 8d 0x 66 0x 67 0x 5 opcode  lea_eax,[eax*2+eax]  0x 00 0x 04 0x 8d 0x 66 0x 67 0x 5 opcode  lea_eax,[eax*2]        0x c4 0x 1 0x 66 0x 3   opcode     add_esp,eax                BIN: return     call pop_code   lea_eax,[eax*2+eax]                  lea_eax,[eax*2] add_esp,eax     ret                        BIN: 2-!   call  pop_code dec_d[eax] dec_d[eax]  ret              0x c0 0x 9f 0x 0f 0x 3  opcode    setg_al                     BIN:  >    call pop_ab  cmp_ebx,eax setg_al  movsx_eax,al                  call push_code  ret                                    0x 08 0x 88 0x 67 0x 3  opcode    mov_[eax],cl                0x 1 0x 48 0x 8a 0x 67 0x 4  opcode mov_cl,[eax+1]                0x d8 0x 39 0x 66 0x 3  opcode  cmp_eax,ebx                           0x 4b 0x 66 0x 2  opcode  dec_ebx                       0x ff 0x 4b 0x 8a 0x 67 0x 4  opcode mov_cl,[ebx-1]               0x 0b 0x 88 0x 67 0x 3  opcode  mov_[ebx],cl                    0x 3 0x 88 0x 67 0x 3 opcode  mov_[ebx],al                   0 0 0 0 0x b5 0x 4 0x 8d 0x 66 0x 67 0x 9 opcode lea_eax,[esi*4]  0x 18 0x 29 0x 66 0x 67 0x 4 opcode sub_[eax],ebx               0x 03 0x 29 0x 66 0x 67 0x 4 opcode sub_[ebx],eax               0x 18 0x 8b 0x 66 0x 67 0x 4 opcode mov_ebx,[eax]               BIN: -!  call pop_ab  sub_[ebx],eax ret                         BIN: CSP    lea_eax,[esi*4]  call push_code  ret                BIN: right_shift_one     call pop_ab   code_top @ label rso          mov_cl,[ebx-1]  mov_[ebx],cl   dec_ebx     cmp_eax,ebx          jne rso  ret                                               BIN: C!     call pop_ab mov_[ebx],al    ret                     BIN: left_shift_one   call pop_ab    code_top @ label lso1           mov_cl,[eax+1]  mov_[eax],cl    inc_eax   cmp_eax,ebx           jne lso1  ret                                                                                                                   0x 42 0x 66 0x 2 opcode inc_edx                                 code_top @                                                      code_top  @ label hc1    rol_ebx,4 mov_al,bl and_al,0fh         mov_ah,30h   aaa_17  mov_[edx],al    inc_edx    ret             BIN: HEXa    call pop_code   mov_edx,eax  call pop_code              mov_ebx,eax     call hc1 call hc1 call hc1 call hc1 call hc1 call hc1 call hc1 call hc1 ret        .. ...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................( Block 4. )                                                     code_top  @ label hc0   rol_ebx,4 mov_al,bl and_al,0fh          mov_ah,30h  aaa_17 mov_ah,0eh int_10h ret                      BIN: 2/  call pop_code shr_eax,1 call push_code ret             BIN: HEX.  call pop_code   mov_ebx,eax call hc0 call hc0        call hc0 call hc0 call hc0 call hc0 call hc0 call hc0   ret     HEX.   BIN: KEY   xor_ax,ax  int_16h call push_code ret         BIN: C@  call pop_code  movzx_eax,b[eax] call push_code ret     BIN: 1+  call pop_code inc_eax  call push_code  ret ;BIN        BIN: CR   mov_ax,0e0dh  int_10h  mov_ax,0e0ah int_10h ret ;BIN  BIN: 1-!  call  pop_code dec_d[eax] ret ;BIN                    code_top  @  label for_scroll  mov_bh,1  mov_ch,3  mov_cl,3     mov_dh,13h   mov_dl,43h  mov_al,1  ret                          BIN: scroll_up   call for_scroll mov_ah,6 int_10h ret ;BIN      BIN: scroll_down  call for_scroll mov_ah,7 int_10h ret ;BIN     BIN: 1-  call pop_code dec_eax  call push_code  ret ;BIN        BIN: 2*  call pop_code shl_eax,1 call push_code  ret  ;BIN      BIN: v-line   call pop_ab  code_top @ label vl7                               mov_w[fs:ebx], w# 1fba  add_ebx, d# a0  dec_eax                 jne  vl7  ret                                     BIN: /  call pop_ab  xor_edx,edx  div_ebx  call push_code               mov_eax,edx     call push_code  ret                     BIN: set_cursor call pop_code  mov_dh,al mov_dl,ah                     mov_ah, b# 02 xor_ebx,ebx int_10h  ret                   BIN:  h-line   call pop_ab  code_top @ label hl2                      mov_w[fs:ebx], w# 1fcd  inc_ebx inc_ebx  dec_eax                jne hl2  ret                                              BIN: draw-corners    call  pop_code  mov_w[fs:eax], w# 1fbc          call  pop_code  mov_w[fs:eax],  w# 1fc8   call  pop_code        mov_w[fs:eax],  w# 1fbb         call  pop_code                  mov_w[fs:eax],  w# 1fc9  ret                               BIN: fill-box   call pop_code   mov_edx,eax     call pop_ab     push_eax        mov_ecx,ebx     xor_ebx,ebx     mov_ah, b# 1f   code_top @     label  fb5     mov_al,[edx]    mov_[fs:ebx],ax   inc_edx         inc_ebx         inc_ebx         dec_ecx         jne fb5         dec_di          pop_ecx         dec_ecx         push_ecx        jne  fb5        ret  pop_ecx    ret             BIN: fb2        call pop_code   push_eax        call pop_ab     mov_ecx,eax     xor_edx,edx     mov_ah, b# 1f   code_top @     label  fb3       mov_al,[ebx]    mov_[fs:edx],ax inc_ebx         inc_edx         inc_edx         dec_ecx         jne fb3         dec_di          pop_ecx         dec_ecx         push_ecx        jne  fb3        ret  pop_ecx    ret                             BIN: print-line call pop_code   mov_ecx,eax     call pop_code   mov_edx,eax     call pop_code   mov_ebx,eax     mov_ah, b# 1f   code_top @    label  pl1      mov_al,[ebx]    mov_[fs:edx],ax   inc_ebx         inc_edx         inc_edx         dec_ecx         jne  pl1  ret                                                                                                                    BIN:  <        call pop_ab     cmp_ebx,eax     setl_al          movsx_eax,al   call push_code  ret                              BIN:  >=       call pop_ab     cmp_ebx,eax     setge_al         movsx_eax,al   call push_code  ret                              BIN: +!         call pop_ab     add_[ebx],eax   ret             BIN: pack_2d_b  call pop_ab     mov_ah,al       mov_al,bl       call push_code  ret                                             BIN: SWAP     call pop_ab     mov_ecx,eax     mov_eax,ebx       call push_code  mov_eax,ecx    call push_code  ret        ..                                                                                                                                                                                                                                                                                                                                                                                                  .( Block 5. )                                                    : MARK  HERE @ ;  : RESOLVE  HERE @ ! ;                         : BEGIN  MARK  ; IMMEDIATE  : AGAIN br_label , , ; IMMEDIATE    : UNTIL   ?br_label , , ; IMMEDIATE                             : ( ) WORD DROP ; IMMEDIATE                                     : WORDS  LATEST BEGIN DUP COUNT 3F AND  TYPE SPACE N>LINK @              DUP 0 <>  UNTIL ;    : VARIABLE  CREATE 0 , ;          : ."   dot_quote_code ,  QUOTE WORD COUNT +  1 + HERE !         ;  IMMEDIATE    : TO  BL WORD FIND DROP >BODY ! ;               : NAME>    N>LINK +CELL ;   VARIABLE (column) VARIABLE (row)    : 0x,  lit_code , 0x , ; IMMEDIATE                              : '  BL WORD FIND DROP ;  : ['] lit_code , ' , ; IMMEDIATE      .( If..Then..Else )                                             : IF ?br_label , MARK 0 , ; IMMEDIATE                           : THEN   MARK  SWAP !  ; IMMEDIATE                              : ELSE MARK +CELL +CELL SWAP ! br_label , MARK 0 , ; IMMEDIATE  .( Key codes )                                                  : backspace? 0x, 0e08 = ;  : delete? 0x, 5300 = ;               : esc? 0x, 11b = ;         : left? 0x, 4b00 = ;                 : right? 0x, 4d00 = ;      : up? 0x, 4800 = ;                   : down? 0x, 5000 = ;       : page_up? 0x, 4900 = ;              : page_down? 0x, 5100 = ;  : home? 0x, 4700 = ;                 : end? 0x, 4f00 = ;                                                                                                             : xy-a   SWAP   0x, 50 * + 2* ;                                 .( Local variables )            : @@1 HERE @ 0x, 100  + ;       : @@2  HERE @    0x, 104  + ;   : @@3  HERE @   0x, 108  + ;    : @@5  HERE @   0x,    110 + ;  : @@4  HERE @   0x, 10c + ;                                                                     : (DUMP) DUP @ HEX. SPACE +CELL ;                               : (CDUMP)  DUP CODE@ HEX. SPACE +CELL ;                         : dump   (DUMP) (DUMP) (DUMP) (DUMP) (DUMP) (DUMP) (DUMP)          (DUMP) (DUMP) (DUMP) ;                                       : cdump (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) ;                                                                                                                       : pack   2* 2* 2* 2* 2* 2* 2* 2* + ;                                                                               ..   ќљ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .( Block 6 )                                                    .( Decompile )                                                  : decompile   0x, 4 - @@1 !  LATEST BEGIN  N>LINK @ DUP                       @@1 @ < UNTIL  COUNT TYPE ;                       .( Windows )                                                    : create_box    CREATE  [ 0x 2 0x 5 xy-a ] , 0x, 40 , 0x, 10 ,      0x, 1000 , 0x,   8 ,               ;                          create_box win1    win1 CONSTANT winname                      : start_adr  winname ;        : width winname +CELL   ;         : height  winname +CELL +CELL ;                                 : symbol  winname +CELL +CELL +CELL ;                           : cursor  winname 0x, 10 +  ;                                   : fill    0 @@1 ! symbol @  @@2 !  BEGIN  @@2 @  start_adr @              @@1 @ + width @   print-line    0x, a0 @@1 +!                 width @ @@2 +!  height @  0x, a0 *  @@1 @  <> UNTIL  ;  : border   start_adr @ 0x, a2 -   start_adr @  width @ 2* +                0x, a0 -  start_adr @  height @ 0x, a0 * + 0x, 2 -              start_adr @  width @ 2* +  height @ 0x, a0 * +                  draw-corners width @  start_adr @ 0x, a0 -  h-line              width @  start_adr @  height @ 0x, a0 * +   h-line              height @ start_adr @ 1- 1-         v-line                       height @ start_adr @ width @ 2* +  v-line ;          : a-xy    0x, a0 /   2/     ;   : w*h  width @  height @ * ;    : a-xy_in_the_box    ( addr width -- x y )  /       ;           : a_b+c_d  ( a b c d -- a+c b+d) @@1 !  @@2 !  @@1 +! @@2 +!               ( b+d, a+c)     @@1 @  @@2 @    ;                    : set_cursor_in_the_box   start_adr  @ a-xy  cursor @  width @       a-xy_in_the_box  a_b+c_d  pack_2d_b  set_cursor  ;         : draw   border fill set_cursor_in_the_box ;                    : do_esc    0x, 114  set_cursor  0x, 2 return  ;                : right-symbol-edge  0x, 2000 w*h - symbol @ < IF  0x, 2000                          w*h - symbol ! THEN ;                      : right-edge   w*h cursor @ < IF cursor 1-! symbol 1+!                         right-symbol-edge THEN ;                         : left-symbol-edge  0x, 1000 symbol @ >= IF 0x, 1000 symbol !      THEN ;                                                       : left-edge   0 cursor @ >= IF cursor 1+! symbol 1-!                          left-symbol-edge  THEN ;                          : do_right    cursor 1+! right-edge   ;                         : do_left     cursor 1-! left-edge ;                            : do_delete   symbol @ cursor @ + 0x, 2000 left_shift_one ;     : do_backspace   do_left do_delete ;                                           ..                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .( Block 7 )                                                    : do_any   DUP  symbol @  cursor @ + DUP  0x, 2000                         right_shift_one C!           do_right  ;             : down_edge_string   width @ symbol +! symbol @ 0x, 2000 w*h -                       > IF  width @ winname symbol -! THEN   ;   : down_edge  cursor @  w*h > IF width @ cursor -!                            down_edge_string THEN  ;                           : do_down    width @ cursor +!   down_edge ;                    : up_edge_string   width @ symbol -! symbol @ 0x, 1000 < IF                  width @ symbol +! THEN ;                           : up_edge  cursor @ 0 < IF width @  cursor +! up_edge_string                            THEN ;                                  : do_up    width @ cursor -! up_edge ;                          : do_home  0x, 1 cursor ! 0x, 1000 symbol ! ;                   : edit    BEGIN  draw KEY  DUP  home? IF DUP up?  IF DUP  down?         IF DUP  esc? IF DUP left? IF DUP  right? IF DUP delete?         IF DUP backspace? IF do_any ELSE do_backspace THEN ELSE        do_delete THEN ELSE do_right THEN ELSE do_left THEN ELSE        do_esc THEN ELSE do_down THEN ELSE do_up THEN ELSE              do_home THEN       DROP     AGAIN ;                      : backup ( save blocks 0-0f to blocks 10-1f  )                           0x, f BEGIN DUP 0x, 2000  RBLOCK DUP 0x, 10 + 0x, 2000          WBLOCK  1- DUP  0 < UNTIL DROP ;                       : block-edit   ( block_number --  )  0x, 1000 RBLOCK edit ;     : block-save   backup  0x, 1000 WBLOCK  ;                        0x 2 0x 24 0x 44 0x 8b 0x 66 0x 67 0x 6 opcode mov_eax,[esp+2]  0x 2 0x 24 0x 44 0x 89 0x 66 0x 67 0x 6 opcode mov_[esp+2],eax  0 0x 8b 0x 66 0x 67 0x 4 opcode mov_eax,[eax]                   0x e3 0x 81 0x 66 0x 3 opcode and_ebx,                          BIN: LIT" mov_eax,[esp+2] add_eax, d# 4  call push_code                   mov_ebx,[eax]  and_ebx, d# ff add_eax,ebx  inc_eax              inc_eax mov_[esp+2],eax ( mov_eax,ebx                     call push_code )  ret                                : ,(     ['] LIT" , ) WORD DUP COUNT + 1+ HERE ! ; IMMEDIATE    : xx CR ,( ooooo ) CR HEX. ;           ...............  ...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................               .( Block 8 )                                                     0x ea 1 opcode jmpf    0x cd 1 opcode int                       BIN: restart  int b# 19                                         0x 31 0x f 0x 2 opcode rdtsc  0x 32 0x f 0x 2 opcode rdmsr      0x a2 0x f 0x 2 opcode cpuid                                    BIN: timestamp  rdtsc call push_code mov_eax,edx                                call push_code ret                              BIN: rd-msr  call pop_code mov_ecx,eax rdmsr call push_code                  mov_eax,edx call push_code ret                     BIN: cpuid_read call pop_code cpuid call push_code mov_eax,ebx    call push_code mov_eax,ecx call push_code mov_eax,edx           call push_code ret                                            : msr. ( n of msr -- value of msr double ) rd-msr HEX. HEX. ;   : basic_cpuid 0 cpuid_read 0x, 604 ! 0x, 608 ! 0x, 600 !  HEX.  SPACE 0x, 600 0x, c TYPE ;                                      : cpu_version 1 cpuid_read HEX. SPACE HEX. SPACE HEX. SPACE        HEX. ;                                                       0x ef 0x 66 0x 2 opcode out_dx,eax                              0x ed 0x 66 0x 2 opcode in_eax,dx                               BIN: pci0  call pop_code or_eax, d# 80000000 mov_dx, w# cf8          out_dx,eax  mov_dx, w# cfc  in_eax,dx call push_code ret   : header.  @@4 @ IF ."  bus\dev\func " ." devid\vendor "         ." class\rev "  CR 0x, 14 @@4 !  ELSE @@4 1-! THEN ;           : adr? 0x, 2000 @@5 @ < IF 0x, 3 return THEN ;                  : HEXadr  @@5 @ HEXa  0x, 8 @@5 +! adr? @@5 @ HEX. SPACE ;      : SPACEadr BL @@5 @ C! @@5 1+! adr? ;                           : pci.  @@1 @ HEX. SPACE @@2 @ HEX. SPACE @@3 @ HEX. CR  ;      : pcia  @@1 @ HEXadr SPACEadr @@2 @ HEXadr SPACEadr @@3 @ HEXadr SPACEadr SPACEadr SPACEadr  ;                                  : pci_get   @@1 @ pci0 @@2 ! @@2 @  0x, ffffffff = IF header. @@1 @ 0x, 8 + pci0 @@3 ! pcia ELSE 1 DROP THEN  ;                 : key? KEY esc? IF SPACE ELSE do_esc THEN ;                     : pci-scan  0x, 1000 @@5 ! 0x, 14 @@4 ! header.   0x, fffff00 @@1 !                         BEGIN  pci_get   0x, 100 @@1 -! @@1 @  0 < UNTIL      ;                    : kek KEY esc? IF pci-scan ELSE EXIT THEN ;                                                             ...........................                      0x ba 0x 66 0x 2 opcode mov_edx,                                0x 2 0x 88 0x 67 0x 3 opcode   mov_[edx],al                     BIN:  +    call pop_ab  add_eax,ebx  call push_code  ret        BIN:  -    call pop_ab  sub_eax,ebx  call push_code  ret        BIN:  *    call pop_ab  imul_ebx     call push_code  ret        BIN: AND   call pop_ab  and_eax,ebx  call push_code  ret        BIN: XOR   call pop_ab  xor_eax,ebx  call push_code  ret        BIN: OR    call pop_ab  or_eax,ebx   call push_code  ret        0x c0 0x 9d 0x 0f 0x 3 opcode   setge_al                        0x ba 1 opcode mov_dx, 0x d 0x 66 0x 2 opcode or_eax,           0x 2 LOAD  0x 3 LOAD  0x 4 LOAD  0x 5 LOAD  0x 6 LOAD           0x 7 LOAD  0x 8 LOAD  CR  .( All blocks loaded ) CR             .( Welcome! )   .. ...............................................................................................................................................................................................................................................bbbbbbbbc.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................... .( Block 1 )                                                    : LATEST    CURRENT @ @ ;  : IMMEDIATE  LATEST    80 OR! ;      : BIN: CREATE code_top  @  to_cf ;  IMMEDIATE                   : ;BIN 0 , ;    IMMEDIATE                                       0x C3 1 opcode ret             0x E8 1 opcode call              0x 20A label pop_code          0x 1FA label push_code           0 0x ff 0x 66 0x 67  0x 4  opcode inc_[eax]                     0x 3 0x 89 0x 67 0x 2e 0x 4 opcode   mov_[cs:ebx],ax            0x 02 0x 00 0x 83 0x 66 0x 67 0x 5 opcode  add_[eax],2          0x 04  0x 00  0x 83 0x 66 0x 67 0x 5 opcode  add_[eax],4        BIN: 1+!  call pop_code  inc_[eax] ret                          0x 3 0x 88 0x 67 0x 2e 0x 4 opcode mov_[cs:ebx],al              0x 3  0x 89 0x 67 0x 66 0x 2e 0x 5 opcode    mov_[cs:ebx],eax   BIN: 2+! call pop_code add_[eax],2  ret                         BIN: 4+! call pop_code  add_[eax],4  ret                        0x C3 0x 89 0x 66 0x 3 opcode mov_ebx,eax                       code_top @   label  pop_ab   call  pop_code  mov_ebx,eax        call  pop_code  ret                                             variable_code label var_        addr_interpreter label addr_i   0x e2 0x 88  0x 2 opcode  mov_dl,ah                             0x c2 0x 89 0x 66 0x 3 opcode mov_edx,eax                       0x c2 0x 81 0x 81 0x 3 opcode add_edx,                          0x c0 0x 81 0x 81 0x 3 opcode add_eax,                          0x d8 0x 01 0x 66 0x 3 opcode add_eax,ebx                       0x d8 0x 29 0x 66 0x 3 opcode sub_eax,ebx                       0x d8 0x 21 0x 66 0x 3 opcode and_eax,ebx                       0x d8 0x 09 0x 66 0x 3 opcode  or_eax,ebx                       0x d8 0x 31 0x 66 0x 3 opcode xor_eax,ebx                       0x eb 0x f7 0x 66 0x 3 opcode imul_ebx                          0x 90 1 opcode nop        0x B8  0x 01 opcode mov_ax,           BIN: bCode,     call pop_ab     mov_[cs:ebx],al ret             BIN: wCode,     call pop_ab     mov_[cs:ebx],ax ret             BIN: dCode,     call pop_ab     mov_[cs:ebx],eax ret            : b# 0x code_top @ bCode, code_top 1+! ;                        : w# 0x code_top @ wCode, code_top 2+! ;                        : d# 0x code_top @ dCode, code_top 4+! ;                        0x ba 0x 66 0x 2 opcode mov_edx,                                0x 2 0x 88 0x 67 0x 3 opcode   mov_[edx],al                     BIN:  +    call pop_ab  add_eax,ebx  call push_code  ret        BIN:  -    call pop_ab  sub_eax,ebx  call push_code  ret        BIN:  *    call pop_ab  imul_ebx     call push_code  ret        BIN: AND   call pop_ab  and_eax,ebx  call push_code  ret        BIN: XOR   call pop_ab  xor_eax,ebx  call push_code  ret        BIN: OR    call pop_ab  or_eax,ebx   call push_code  ret        0x c0 0x 9d 0x 0f 0x 3 opcode   setge_al                        0x ba 1 opcode mov_dx, 0x d 0x 66 0x 2 opcode or_eax,           0x 2 LOAD  0x 3 LOAD  0x 4 LOAD  0x 5 LOAD  0x 6 LOAD           0x 7 LOAD  0x 8 LOAD  CR  .( All blocks loaded ) CR             .( Welcome! )   .. ...............................................................................................................................................................................................................................................bbbbbbbbc.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................... .( Block 2. )                                                   0x 0E 0x 0D 0x B8 0x 03  opcode    mov_ax,0e0dh                 0x 0E 0x 0A 0x B8 0x  3  opcode    mov_ax,0e0ah                 0x 10 0x CD 0x 2         opcode    int_10h                      0x 0E 0x B4 0x 2         opcode    mov_ah,0eh                   0x 11 0x D5 0x 37 0x 3   opcode    aaa_17                       0x 30 0x B4 0x 2         opcode    mov_ah,30h                   0x 0F 0x 24 0x 2         opcode    and_al,0fh                   0x D8 0x 88 0x 2         opcode    mov_al,bl                    0x 04 0x C3 0x C1 0x 66 0x 4   opcode   rol_ebx,4               0x 43 1  opcode  inc_bx   0x C0 0x 31 0x 2 opcode xor_ax,ax     0x 16 0x CD 0x 2 opcode int_16h                                 0x 0 0x B6 0x 0F 0x 66 0x 67 0x 5 opcode movzx_eax,b[eax]       0x 40 0x 66 0x 2 opcode  inc_eax                                0x 08 0x FF 0x 66 0x 67 0x 04  opcode dec_d[eax]                0x 01 0x b7 0x 2         opcode     mov_bh,1                    0x 03 0x b5 0x 2         opcode     mov_ch,3                    0x  3 0x b1 0x 2         opcode     mov_cl,3                    0x 13 0x b6 0x 2         opcode     mov_dh,13h                  0x 43 0x 43 0x 2 opcode mov_dl,43h                              1 0x b0 0x 2 opcode mov_al,1  0x 6 0x B4 0x 2 opcode mov_ah,6   0x  7 0x B4 0x 2         opcode     mov_ah,7                    0x  7 0x c7 0x 64 0x 3   opcode     mov_[fs:bx],                0x e2 1 opcode loop      0x c3 0x 89 0x 2 opcode mov_bx,ax      0x b9 1 opcode mov_cx, 0x e0 0x d1 0x 66 0x 3 opcode shl_eax,1  0x c3 0x 81 0x 2 opcode add_bx,                                 0x 3 0x c7 0x 67 0x 64 0x 4    opcode          mov_w[fs:ebx],   0x 48 0x 66 0x 2 opcode  dec_eax   0x 85 0x f 0x 2 opcode  jne  0x 43 0x 66 0x 2 opcode  inc_ebx                                0x c3 0x 81 0x 66 0x 3  opcode  add_ebx,                        0x 0 0x c7 0x 67 0x 64  0x 4    opcode   mov_w[fs:eax],         0x e0 0x c1 0x 66 0x 3 opcode   shl_eax,                        0x 50  0x 66    0x 2  opcode    push_eax                        0x db 0x 31 0x 66 0x 3  opcode  xor_ebx,ebx                     0x 02 0x 8a 0x 67 0x 3  opcode  mov_al,[edx]                    0x 59 0x 66 0x 2 opcode pop_ecx 0x 49 0x 66 0x 2 opcode dec_ecx 0x 42 0x 66 0x 2 opcode inc_edx                                 0x d9 0x 89 0x 2 opcode   mov_ecx,ebx                           0x B4 1 opcode mov_ah,         0x 4f 1 opcode dec_di            0x 3 0x 89 0x 67 0x 64 0x 4  opcode   mov_[fs:ebx],ax           0x 51 0x 66 0x 2 opcode push_ecx                                0x c1 0x 89 0x 66  0x 3  opcode mov_ecx,eax                     0x d2 0x 31 0x  66 0x 3  opcode xor_edx,edx                     0x 03 0x 8a 0x  67 0x 3  opcode  mov_al,[ebx]                   0x 2 0x 89 0x 67 0x 64  0x 4  opcode  mov_[fs:edx],ax           0x b8 0x 66 0x 2 opcode  mov_eax,     0x e9 1  opcode  jmp      0x c0 0x 9c 0x 0f 0x 3 opcode   setl_al                         0x c0 0x 9e 0x 0f 0x 3 opcode   setle_al                        0x c3 0x 39 0x 66 0x 3 opcode   cmp_ebx,eax                     0x c0 0x be 0x 0f 0x 66 0x 4   opcode movsx_eax,al              0x 3 0x 01 0x 66 0x 67 0x 4 opcode  add_[ebx],eax               0x 18 0x 01 0x 66 0x 67 0x 4 opcode  add_[eax],ebx              0x 3 0x 01 0x 66 0x 67 0x 64 0x 5  opcode  add_fs:[ebx],eax     0x e8 0x d1 0x 66 0x 3 opcode  shr_eax,1                        0x f3 0x f7 0x 66 0x 3  opcode  div_ebx                         0x c4 0x 88 0x 2 opcode mov_ah,al                               0x d0 0x 89 0x 66   0x 3 opcode  mov_eax,edx                    0x c6 0x 88         0x 2 opcode mov_dh,al                                          ..        ..                                                                                                                                                                                                                                                                                                                                                                 .( Block 3 )                                                    : NAME>    N>LINK +CELL ;     LATEST NAME> CONSTANT  does-d     : part-one     call  var_    mov_eax, ;                         : part-two     jmp  addr_i  ;                                   : DOES>        code_top @ lit_code , , does-d ,                     HERE @ part-one        code_top @ dCode,      code_top 4+!      part-two   ret_ ,  ; IMMEDIATE                                0x d8 0x 89 0x 66 0x 3  opcode     mov_eax,ebx                  0x c8 0x 89 0x 66 0x 3  opcode     mov_eax,ecx                0x 40 0x 04 0x 8d 0x 66 0x 67 0x 5 opcode  lea_eax,[eax*2+eax]  0x 00 0x 04 0x 8d 0x 66 0x 67 0x 5 opcode  lea_eax,[eax*2]        0x c4 0x 1 0x 66 0x 3   opcode     add_esp,eax                BIN: return     call pop_code   lea_eax,[eax*2+eax]                  lea_eax,[eax*2] add_esp,eax     ret                        BIN: 2-!   call  pop_code dec_d[eax] dec_d[eax]  ret              0x c0 0x 9f 0x 0f 0x 3  opcode    setg_al                     BIN:  >    call pop_ab  cmp_ebx,eax setg_al  movsx_eax,al                  call push_code  ret                                    0x 08 0x 88 0x 67 0x 3  opcode    mov_[eax],cl                0x 1 0x 48 0x 8a 0x 67 0x 4  opcode mov_cl,[eax+1]                0x d8 0x 39 0x 66 0x 3  opcode  cmp_eax,ebx                           0x 4b 0x 66 0x 2  opcode  dec_ebx                       0x ff 0x 4b 0x 8a 0x 67 0x 4  opcode mov_cl,[ebx-1]               0x 0b 0x 88 0x 67 0x 3  opcode  mov_[ebx],cl                    0x 3 0x 88 0x 67 0x 3 opcode  mov_[ebx],al                   0 0 0 0 0x b5 0x 4 0x 8d 0x 66 0x 67 0x 9 opcode lea_eax,[esi*4]  0x 18 0x 29 0x 66 0x 67 0x 4 opcode sub_[eax],ebx               0x 03 0x 29 0x 66 0x 67 0x 4 opcode sub_[ebx],eax                                                                               BIN: -!  call pop_ab  sub_[ebx],eax ret                         BIN: CSP    lea_eax,[esi*4]  call push_code  ret                BIN: right_shift_one     call pop_ab   code_top @ label rso          mov_cl,[ebx-1]  mov_[ebx],cl   dec_ebx     cmp_eax,ebx          jne rso  ret                                               BIN: poke_symbol     call pop_ab mov_[ebx],al    ret            BIN: left_shift_one   call pop_ab    code_top @ label lso1           mov_cl,[eax+1]  mov_[eax],cl    inc_eax   cmp_eax,ebx           jne lso1  ret                                                                                                                   0x 42 0x 66 0x 2 opcode inc_edx                                 code_top @                                                      code_top  @ label hc1    rol_ebx,4 mov_al,bl and_al,0fh         mov_ah,30h   aaa_17  mov_[edx],al    inc_edx    ret             BIN: HEXa    call pop_code   mov_edx,eax  call pop_code              mov_ebx,eax     call hc1 call hc1 call hc1 call hc1 call hc1 call hc1 call hc1 call hc1 ret        .. ...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................( Block 4. )                                                     code_top  @ label hc0   rol_ebx,4 mov_al,bl and_al,0fh          mov_ah,30h  aaa_17 mov_ah,0eh int_10h ret                      BIN: 2/  call pop_code shr_eax,1 call push_code ret             BIN: HEX.  call pop_code   mov_ebx,eax call hc0 call hc0        call hc0 call hc0 call hc0 call hc0 call hc0 call hc0   ret     HEX.   BIN: KEY   xor_ax,ax  int_16h call push_code ret         BIN: C@  call pop_code  movzx_eax,b[eax] call push_code ret     BIN: 1+  call pop_code inc_eax  call push_code  ret ;BIN        BIN: CR   mov_ax,0e0dh  int_10h  mov_ax,0e0ah int_10h ret ;BIN  BIN: 1-!  call  pop_code dec_d[eax] ret ;BIN                    code_top  @  label for_scroll  mov_bh,1  mov_ch,3  mov_cl,3     mov_dh,13h   mov_dl,43h  mov_al,1  ret                          BIN: scroll_up   call for_scroll mov_ah,6 int_10h ret ;BIN      BIN: scroll_down  call for_scroll mov_ah,7 int_10h ret ;BIN     BIN: 1-  call pop_code dec_eax  call push_code  ret ;BIN        BIN: 2*  call pop_code shl_eax,1 call push_code  ret  ;BIN      BIN: v-line   call pop_ab  code_top @ label vl7                               mov_w[fs:ebx], w# 1fba  add_ebx, d# a0  dec_eax                 jne  vl7  ret                                     BIN: /  call pop_ab  xor_edx,edx  div_ebx  call push_code               mov_eax,edx     call push_code  ret                     BIN: set_cursor call pop_code  mov_dh,al mov_dl,ah                     mov_ah, b# 02 xor_ebx,ebx int_10h  ret                   BIN:  h-line   call pop_ab  code_top @ label hl2                      mov_w[fs:ebx], w# 1fcd  inc_ebx inc_ebx  dec_eax                jne hl2  ret                                              BIN: draw-corners    call  pop_code  mov_w[fs:eax], w# 1fbc          call  pop_code  mov_w[fs:eax],  w# 1fc8   call  pop_code        mov_w[fs:eax],  w# 1fbb         call  pop_code                  mov_w[fs:eax],  w# 1fc9  ret                               BIN: fill-box   call pop_code   mov_edx,eax     call pop_ab     push_eax        mov_ecx,ebx     xor_ebx,ebx     mov_ah, b# 1f   code_top @     label  fb5     mov_al,[edx]    mov_[fs:ebx],ax   inc_edx         inc_ebx         inc_ebx         dec_ecx         jne fb5         dec_di          pop_ecx         dec_ecx         push_ecx        jne  fb5        ret  pop_ecx    ret             BIN: fb2        call pop_code   push_eax        call pop_ab     mov_ecx,eax     xor_edx,edx     mov_ah, b# 1f   code_top @     label  fb3       mov_al,[ebx]    mov_[fs:edx],ax inc_ebx         inc_edx         inc_edx         dec_ecx         jne fb3         dec_di          pop_ecx         dec_ecx         push_ecx        jne  fb3        ret  pop_ecx    ret                             BIN: print-line call pop_code   mov_ecx,eax     call pop_code   mov_edx,eax     call pop_code   mov_ebx,eax     mov_ah, b# 1f   code_top @    label  pl1      mov_al,[ebx]    mov_[fs:edx],ax   inc_ebx         inc_edx         inc_edx         dec_ecx         jne  pl1  ret                                                                                                                    BIN:  <        call pop_ab     cmp_ebx,eax     setl_al          movsx_eax,al   call push_code  ret                              BIN:  >=       call pop_ab     cmp_ebx,eax     setge_al         movsx_eax,al   call push_code  ret                              BIN: +!         call pop_ab     add_[ebx],eax   ret             BIN: pack_2d_b  call pop_ab     mov_ah,al       mov_al,bl       call push_code  ret                                             BIN: SWAP     call pop_ab     mov_ecx,eax     mov_eax,ebx       call push_code  mov_eax,ecx    call push_code  ret        ..                                                                                                                                                                                                                                                                                                                                                                                                  .( Block 5. )                                                    : MARK  HERE @ ;  : RESOLVE  HERE @ ! ;                         : BEGIN  MARK  ; IMMEDIATE  : AGAIN br_label , , ; IMMEDIATE    : UNTIL   ?br_label , , ; IMMEDIATE                             : ( ) WORD DROP ; IMMEDIATE                                     : WORDS  LATEST BEGIN DUP COUNT 3F AND  TYPE SPACE N>LINK @              DUP 0 <>  UNTIL ;    : VARIABLE  CREATE 0 , ;          : ."   dot_quote_code ,  QUOTE WORD COUNT +  1 + HERE !         ;  IMMEDIATE    : TO  BL WORD FIND DROP >BODY ! ;               : NAME>    N>LINK +CELL ;   VARIABLE (column) VARIABLE (row)    : 0x,  lit_code , 0x , ; IMMEDIATE                              .( If..Then..Else )                                             : IF ?br_label , MARK 0 , ; IMMEDIATE                           : THEN   MARK  SWAP !  ; IMMEDIATE                              : ELSE MARK +CELL +CELL SWAP ! br_label , MARK 0 , ; IMMEDIATE  .( Key codes )                                                  : backspace? 0x, 0e08 = ;  : delete? 0x, 5300 = ;               : esc? 0x, 11b = ;         : left? 0x, 4b00 = ;                 : right? 0x, 4d00 = ;      : up? 0x, 4800 = ;                   : down? 0x, 5000 = ;       : page_up? 0x, 4900 = ;              : page_down? 0x, 5100 = ;  : home? 0x, 4700 = ;                 : end? 0x, 4f00 = ;                                                                                                             : xy-a   SWAP   0x, 50 * + 2* ;                                 .( Local variables )            : @@1 HERE @ 0x, 100  + ;       : @@2  HERE @    0x, 104  + ;   : @@3  HERE @   0x, 108  + ;    : @@5  HERE @   0x,    110 + ;  : @@4  HERE @   0x, 10c + ;                                                                     : (DUMP) DUP @ HEX. SPACE +CELL ;                               : (CDUMP)  DUP CODE@ HEX. SPACE +CELL ;                         : dump   (DUMP) (DUMP) (DUMP) (DUMP) (DUMP) (DUMP) (DUMP)          (DUMP)  ;                                                    : cdump (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) (CDUMP) ;                                                                                                                       : pack   2* 2* 2* 2* 2* 2* 2* 2* + ;                                                                               ..   ќљ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .( Block 6 )                                                    .( Decompile )                                                  : decompile   0x, 4 - @@1 !  LATEST BEGIN  N>LINK @ DUP                       @@1 @ < UNTIL  COUNT TYPE ;                       .( Windows )                                                    : create_box    CREATE  [ 0x 2 0x 5 xy-a ] , 0x, 40 , 0x, 10 ,      0x, 1000 , 0x,   8 ,               ;                          create_box win1    win1 CONSTANT winname                      : start_adr  winname ;        : width winname +CELL   ;         : height  winname +CELL +CELL ;                                 : symbol  winname +CELL +CELL +CELL ;                           : cursor  winname 0x, 10 +  ;                                   : fill    0 @@1 ! symbol @  @@2 !  BEGIN  @@2 @  start_adr @              @@1 @ + width @   print-line    0x, a0 @@1 +!                 width @ @@2 +!  height @  0x, a0 *  @@1 @  <> UNTIL  ;  : border   start_adr @ 0x, a2 -   start_adr @  width @ 2* +                0x, a0 -  start_adr @  height @ 0x, a0 * + 0x, 2 -              start_adr @  width @ 2* +  height @ 0x, a0 * +                  draw-corners width @  start_adr @ 0x, a0 -  h-line              width @  start_adr @  height @ 0x, a0 * +   h-line              height @ start_adr @ 1- 1-         v-line                       height @ start_adr @ width @ 2* +  v-line ;          : a-xy    0x, a0 /   2/     ;   : w*h  width @  height @ * ;    : a-xy_in_the_box    ( addr width -- x y )  /       ;           : a_b+c_d  ( a b c d -- a+c b+d) @@1 !  @@2 !  @@1 +! @@2 +!               ( b+d, a+c)     @@1 @  @@2 @    ;                    : set_cursor_in_the_box   start_adr  @ a-xy  cursor @  width @       a-xy_in_the_box  a_b+c_d  pack_2d_b  set_cursor  ;         : draw   border fill set_cursor_in_the_box ;                    : do_esc    0x, 114  set_cursor  0x, 2 return  ;                : right-symbol-edge  0x, 2000 w*h - symbol @ < IF  0x, 2000                          w*h - symbol ! THEN ;                      : right-edge   w*h cursor @ < IF cursor 1-! symbol 1+!                         right-symbol-edge THEN ;                         : left-symbol-edge  0x, 1000 symbol @ >= IF 0x, 1000 symbol !      THEN ;                                                       : left-edge   0 cursor @ >= IF cursor 1+! symbol 1-!                          left-symbol-edge  THEN ;                          : do_right    cursor 1+! right-edge   ;                         : do_left     cursor 1-! left-edge ;                            : do_delete   symbol @ cursor @ + 0x, 2000 left_shift_one ;     : do_backspace   do_left do_delete ;                                           ..                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .( Block 7 )                                                    : do_any   DUP  symbol @  cursor @ + DUP  0x, 2000                         right_shift_one poke_symbol  do_right  ;             : down_edge_string   width @ symbol +! symbol @ 0x, 2000 w*h -                       > IF  width @ winname symbol -! THEN   ;   : down_edge  cursor @  w*h > IF width @ cursor -!                            down_edge_string THEN  ;                           : do_down    width @ cursor +!   down_edge ;                    : up_edge_string   width @ symbol -! symbol @ 0x, 1000 < IF                  width @ symbol +! THEN ;                           : up_edge  cursor @ 0 < IF width @  cursor +! up_edge_string                            THEN ;                                  : do_up    width @ cursor -! up_edge ;                          : do_home  0x, 1 cursor ! 0x, 1000 symbol ! ;                   : edit    BEGIN  draw KEY  DUP  home? IF DUP up?  IF DUP  down?         IF DUP  esc? IF DUP left? IF DUP  right? IF DUP delete?         IF DUP backspace? IF do_any ELSE do_backspace THEN ELSE        do_delete THEN ELSE do_right THEN ELSE do_left THEN ELSE        do_esc THEN ELSE do_down THEN ELSE do_up THEN ELSE              do_home THEN       DROP     AGAIN ;                      : backup ( save blocks 0-0f to blocks 10-1f  )                           0x, f BEGIN DUP 0x, 2000  RBLOCK DUP 0x, 10 + 0x, 2000          WBLOCK  1- DUP  0 < UNTIL DROP ;                       : block-edit   ( block_number --  )  0x, 1000 RBLOCK edit ;     : block-save   backup  0x, 1000 WBLOCK  ;   ...............  ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................( Block 8 )                                                     0x ea 1 opcode jmpf    0x cd 1 opcode int                       BIN: restart  int b# 19                                         0x 31 0x f 0x 2 opcode rdtsc  0x 32 0x f 0x 2 opcode rdmsr      0x a2 0x f 0x 2 opcode cpuid                                    BIN: timestamp  rdtsc call push_code mov_eax,edx                                call push_code ret                              BIN: rd-msr  call pop_code mov_ecx,eax rdmsr call push_code                  mov_eax,edx call push_code ret                     BIN: cpuid_read call pop_code cpuid call push_code mov_eax,ebx    call push_code mov_eax,ecx call push_code mov_eax,edx           call push_code ret                                            : msr. ( n of msr -- value of msr double ) rd-msr HEX. HEX. ;   : basic_cpuid 0 cpuid_read 0x, 604 ! 0x, 608 ! 0x, 600 !  HEX.  SPACE 0x, 600 0x, c TYPE ;                                      : cpu_version 1 cpuid_read HEX. SPACE HEX. SPACE HEX. SPACE        HEX. ;                                                       0x ef 0x 66 0x 2 opcode out_dx,eax                              0x ed 0x 66 0x 2 opcode in_eax,dx                               BIN: pci0  call pop_code or_eax, d# 80000000 mov_dx, w# cf8          out_dx,eax  mov_dx, w# cfc  in_eax,dx call push_code ret   : pci.  @@1 ! @@1 @ pci0 DUP    0x, ffffffff = IF @@1 @ HEX.            SPACE HEX. SPACE  @@1 @ 0x, 8 + pci0 HEX. CR  ELSE DROP   THEN ;                                                        : pci-scan  0x, fffff00 BEGIN DUP pci. 0x, 100 - DUP  0 < UNTIL  DROP ;       : buses 0x, ff00000 BEGIN DUP devices   0x, 100000 - DUP 0 < UNTIL DROP ;        : devc 0x, ff8000 BEGIN DUP pci0 HEX. SPACE KEY DROP 0x, 8000 - DUP 0 < UNTIL ;                                                 
